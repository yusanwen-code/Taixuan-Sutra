# 三大范式

## 1. 第一范式（1NF，确保每列保持原子性）

第一范式要求数据库中的每个表格的每个字段（列）都具有原子性，即字段中的值不可再分割。换句话说，每个字段只能存储一个单一的值，不能包含集合、数组或重复的组。

**如下示例：** 假设有一个学生表 Student，结构如下：

| 学生ID | 姓名 | 电话号码              |
|--------|------|-----------------------|
| 1      | 张三 | 123456789, 987654321  |
| 2      | 李四 | 555555555             |

在这个表中，电话号码字段包含多个号码，违反了 1NF 的原子性要求。为了满足 1NF，需要将电话号码拆分为单独的记录或创建一个新的表。

**满足 1NF 后的设计：**

**学生表 Student**

| 学生ID | 姓名 |
|--------|------|
| 1      | 张三 |
| 2      | 李四 |

**电话表 Phone**

| 电话ID | 学生ID | 电话号码   |
|--------|--------|------------|
| 1      | 1      | 123456789  |
| 2      | 1      | 987654321  |
| 3      | 2      | 555555555  |

---

## 2. 第二范式（2NF，确保表中的每列都和主键相关）

第二范式要求满足第一范式，并且消除表中的部分依赖，即非主键字段必须完全依赖于主键，而不是仅依赖于主键的一部分。这主要适用于复合主键的情况。

**如下示例：** 假设有一个订单详情表 OrderDetail，结构如下：

| 订单ID | 商品ID | 商品名称 | 数量 | 单价 |
|--------|--------|----------|------|------|
| 1001   | A01    | 苹果     | 10   | 2.5  |
| 1001   | A02    | 橙子     | 5    | 3.0  |
| 1002   | A01    | 苹果     | 7    | 2.5  |

在上述表中，主键是复合主键 (订单ID, 商品ID)。商品名称和单价只依赖于商品ID，而不是整个主键，存在部分依赖，违反了 2NF。

**满足 2NF 后的设计：**

**订单详情表 OrderDetail**

| 订单ID | 商品ID | 数量 |
|--------|--------|------|
| 1001   | A01    | 10   |
| 1001   | A02    | 5    |
| 1002   | A01    | 7    |

**商品表 Product**

| 商品ID | 商品名称 | 单价 |
|--------|----------|------|
| A01    | 苹果     | 2.5  |
| A02    | 橙子     | 3.0  |

---

## 3. 第三范式（3NF，确保每列都和主键列直接相关，而不是间接相关）

第三范式要求满足第二范式，并且消除表中的传递依赖，即非主键字段不应依赖于其他非主键字段。换句话说，所有非主键字段必须直接依赖于主键，而不是通过其他非主键字段间接依赖。

**如下示例：** 假设有一个员工表 Employee，结构如下：

| 员工ID | 员工姓名 | 部门ID | 部门名称 |
|--------|----------|--------|----------|
| E01    | 王五     | D01    | 销售部   |
| E02    | 赵六     | D02    | 技术部   |
| E03    | 孙七     | D01    | 销售部   |

在这个表中，部门名称依赖于部门ID，而部门ID依赖于主键员工ID，形成了传递依赖，违反了 3NF。

**满足 3NF 后的设计：**

**员工表 Employee**

| 员工ID | 员工姓名 | 部门ID |
|--------|----------|--------|
| E01    | 王五     | D01    |
| E02    | 赵六     | D02    |
| E03    | 孙七     | D01    |

**部门表 Department**

| 部门ID | 部门名称 |
|--------|----------|
| D01    | 销售部   |
| D02    | 技术部   |

---

## 三大范式总结

- **第一范式（1NF）**：确保每个字段的值都是原子性的，不可再分。
- **第二范式（2NF）**：在满足 1NF 的基础上，消除部分依赖，确保非主键字段完全依赖于主键。
- **第三范式（3NF）**：在满足 2NF 的基础上，消除传递依赖，确保非主键字段直接依赖于主键。

---

# 破坏三范式

尽管遵循数据库的三大范式（1NF、2NF、3NF）有助于提高数据的一致性和减少冗余，但在实际工作中，为了满足性能、简化设计或特定业务需求，我们可能需要**违反这些范式**。

以下是常见的破坏三范式的场景及示例：

## 2.1 性能优化

在高并发、大数据量的应用场景中，严格遵循三范式可能导致频繁的联表查询，影响系统性能。设计者可能会**冗余存储**部分数据来避免联表。

**示例：** 电商系统中，订单表 Orders 和用户表 Users：

**冗余设计后的订单表：**

| 订单ID | 用户ID | 用户姓名 | 用户地址 | 订单日期     | 总金额 |
|--------|--------|----------|----------|--------------|--------|
| 1001   | U01    | 张三     | 北京市   | 2023-10-01   | 500元  |
| 1002   | U02    | 李四     | 上海市   | 2023-10-02   | 300元  |

这样查询订单时无需联表 Users 表，提升性能。

---

## 2.2 简化查询和开发

范式过于严格可能增加开发复杂度，为了简化前端逻辑或开发流程，也会有意进行冗余设计。

**示例：** 内容管理系统（CMS）中文章表和分类表：

**破坏 3NF 的设计：**

| 文章ID | 标题   | 内容 | 分类ID | 分类名称 |
|--------|--------|------|--------|----------|
| A01    | 文章一 | …    | C01    | 技术     |
| A02    | 文章二 | …    | C02    | 生活     |

避免频繁联表查询 Categories 表，便于开发。

---

## 2.3 报表和数据仓库

为了提高分析效率，数据仓库常使用**星型或雪花型结构**，会对数据进行冗余设计。

**示例：**

| 销售ID | 产品ID | 产品名称 | 类别 | 销售数量 | 销售金额 | 销售日期   |
|--------|--------|----------|------|----------|----------|------------|
| S01    | P01    | 手机     | 电子 | 100      | 50000元  | 2023-10-01 |
| S02    | P02    | 书籍     | 教育 | 200      | 20000元  | 2023-10-02 |

避免频繁查询维度表，提高报表性能。

---

## 2.4 特殊业务需求

有些业务对响应速度要求极高，可以冗余存储计算结果，牺牲部分一致性换取效率。

**示例：** 实时交易系统中，用户当前余额存储在用户表中：

| 用户ID | 用户名 | 当前余额 |
|--------|--------|----------|
| U01    | 王五   | 10000元  |
| U02    | 赵六   | 5000元   |

而不是每次查询都去汇总交易记录，提升速度。

---

## 2.5 兼顾读写性能

读多写少场景下，为提升读取性能可以使用冗余结构，即使写入代价较高。

**示例：** 社交平台中展示好友数量：

| 用户ID | 用户名 | 好友数量 |
|--------|--------|----------|
| U01    | 张三   | 250      |
| U02    | 李四   | 180      |

避免每次请求都去 count 好友关系表。

---

以上这些都是破坏三范式的常见动因，设计时要根据具体业务权衡范式与性能、可维护性之间的关系。
