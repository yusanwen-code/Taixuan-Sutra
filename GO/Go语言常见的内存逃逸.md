# 什么是内存逃逸?
​函数的内存默认是在栈上进行分配,每一个函数都会分配一个栈帧,在函数运行结束进行消费,如果变量在函数运行结束后没有进行回收,那么内存将重新分配,分配到堆中,但是堆的内存是需要GC去清理的,清理的时候对函数运行有影响,这个现象叫内存逃逸.


# 如何检测内存逃逸
1. gcflags 
```
go build -gcflags '-m' main.go  可以展示逃逸分析、内联优化等各种优化结果。
```
```
go build -gcflags="-m -l"，-l会禁用内联优化，这样可以过滤掉内联优化的结果展示，让我们可以关注逃逸分析的结果。
```
```
go build -gcflags="-m -m"，多一个-m会展示更详细的分析结果。
```

2. pprof


# 逃逸机制
1. 若果函数外部没有引用,优先放在栈中
2. 如果函数外部存在引用,则必然放在堆中
3. ​如果栈上放不下,则必定放在堆中


# 常见的几种内存逃逸
1. 返回值是指针(指针逃逸)
2. 栈空间不足,Go语言栈默认大小为2K
3. 闭包 



## 如何避免内存逃逸
1. 严格限制变量的作用域。如果一个变量只在函数内部使用，就不要将其返回或赋值给外部变量。
2. 使用值而不是指针，当不必要的时候，尽量使用值传递而不是指针传递。
3. 池化对象，对于频繁创建和销毁的对象，考虑使用对象池技术进行复用，减少在堆上分配和回收对象的次数。
4. 尽量避免在循环或频繁调用的函数中创建闭包，以减少外部变量的引用和堆分配，避免使用不必要的闭包，闭包可能会导致内存逃逸。
5. 优化数据结构，使用固定大小的数据结构，避免使用动态大小的切片和 map。比如使用数组而不是切片，因为数组的大小在编译时就已确定。
6. 预分配切片和 map 的容量，如果知道切片或 map 的大小，预先分配足够的容量可以避免在运行时重新分配内存。